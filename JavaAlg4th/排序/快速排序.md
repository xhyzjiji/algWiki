## 原理

1. 寻找元素a[k]所在数组的正确位置p，保证

$$
a[0]...a[p-1] \leq a[k] \leq a[p+1]...a[N]
$$

2. 分治思想，对a[0]...a[p-1]和a[p+1]...a[N]子数组进行排序



## 步骤

1. 选择数组中的一个元素a[k]；
2. 左右指针从数组头尾向中间靠近，原则上保证

$$
a[low] \leq a[k] \leq a[high]
$$

3. 当左右指针均遇到不满足上面条件时，交换指针所指位置元素
4. 重复步骤2，直至左右指针相遇，位置为p
5. a[k]与a[p]交换，数组被分成两个子数组，子数组重复1~4进行排序



## 实现

```java
public class QuickSort {

    public static void sort(int[] a) {
        subSort(a, 0, a.length-1);
    }

    private static int findPosition(int[] a, int low, int high) {
        // 取头部的好处在于循环体内的比较和交换与a[k]无关，去除a[k]元素，数组还是连续的
        int k = low;
        while (low < high) {
            // 最后一次循环中，可以认为满足条件的p位置已经存在，第一个循环体使low停在比a[k]大的位置，第二个循环体因为low<high，使得high会停在比a[k]大的位置（low==high）
            // 而a[k]需要与比他小的元素交换，下面注释掉的实现是不满足要求的
            /*
            while (low < high && a[low] <= a[k]) {
                low++;
            }
            while (low < high && a[high] >= a[k]) {
                high--;
            }
            */

            // 最后一次循环中，可以认为满足条件的p位置已经存在，第一个循环体使high停在比a[k]小的位置，第二个循环体因为low<high，使得low会停在比a[k]大的位置（low==high）
            // 正确的实现方式
            while (low < high && a[high] >= a[k]) {
                high--;
            }
            while (low < high && a[low] <= a[k]) {
                low++;
            }

            swap(a, low, high);
        }
        swap(a, k, low);
        return low;
    }

    private static void subSort(int[] a, int low, int high) {
        if (low >= high) {
            return;
        }
        int p = findPosition(a, low, high);
        subSort(a, low, p-1);
        subSort(a, p+1, high);
    }

    private static void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    public static void main(String[] args) {
        int[] tc = new int[]{10, 9, 8, 7, 6, 5,4,3,2,1};
        sort(tc);
        System.out.println(Arrays.toString(tc));
    }

}
```

