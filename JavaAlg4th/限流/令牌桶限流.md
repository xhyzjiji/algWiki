## 原理

![img](https://images2018.cnblogs.com/blog/874963/201807/874963-20180727184550598-845634570.png)

原理很简单：在队列化后的请求处理前，先获取执行许可，如果可以获取，则执行，否则，等待直至通过。



## 步骤

1.外部源源不断地产生令牌放入令牌桶，当超过桶容量时，丢弃令牌

2.请求处理前先从桶内获取令牌，如果桶能提供需要的令牌数量，则处理请求，否则阻塞直到令牌数量满足要求



## 实现

Guava的RateLimiter实现了令牌桶，且有两种实现方式：SmoothBursty和SmoothWarmingUp。

SmoothBursty会匀速生产令牌，且消耗令牌不需要时间，比较简单，我们直接进入下SmoothWarmingUp的实现，SmoothWarmingUp生产令牌满足下图规则。

<img src="/Users/panyongfeng/Library/Application Support/typora-user-images/image-20200217020142997.png" alt="image-20200217020142997" style="zoom:50%;" />

其中，
$$
T_{P_a \rightarrow P_b} = \int_{P_a}^{P_b}t(P)dt
$$
桶空闲时，令牌数从Pa到Pb需要时间为生产时间函数的定积分。

首先需要清楚一些参数概念

```java
	 *          ^ throttling
   *          |
   *    cold  +                  /
   * interval |                 /.
   *          |                / .
   *          |               /  .   ← "warmup period" is the area of the trapezoid between
   *          |              /   .     thresholdPermits and maxPermits
   *          |             /    .
   *          |            /     .
   *          |           /      .
   *   stable +----------/  WARM .
   * interval |          .   UP  .
   *          |          . PERIOD.
   *          |          .       .
   *        0 +----------+-------+--------------→ storedPermits
   *          0 thresholdPermits maxPermits
void doSetRate(double permitsPerSecond, double stableIntervalMicros) {
      double oldMaxPermits = maxPermits;
      double coldIntervalMicros = stableIntervalMicros * coldFactor;
      thresholdPermits = 0.5 * warmupPeriodMicros / stableIntervalMicros;
      maxPermits =
          thresholdPermits + 2.0 * warmupPeriodMicros / (stableIntervalMicros + coldIntervalMicros);
      slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits - thresholdPermits);
      if (oldMaxPermits == Double.POSITIVE_INFINITY) {
        // if we don't special-case this, we would get storedPermits == NaN, below
        storedPermits = 0.0;
      } else {
        storedPermits =
            (oldMaxPermits == 0.0)
                ? maxPermits // initial state is cold
                : storedPermits * maxPermits / oldMaxPermits;
      }
    }
```

| 参数名               | 文中别名 | 含义                                      |
| -------------------- | -------- | ----------------------------------------- |
| stableIntervalMicros | ts       | 桶内令牌数低于Pt时按设置的QPS速率生产令牌 |
| coldIntervalMicros   | tc       | 桶满时令牌生产时间                        |
| thresholdPermits     | Pt       | 生产令牌                                  |
| maxPermits           | Pm       | 桶容量                                    |
| slope                | skew     | warmUp区生产令牌时间变化斜率              |
| warmupPeriodMicros   | Tw       | 限流器空闲时令牌数从Pt到Pm耗时            |

从doSetRate方法中，我们可以了解到：

1. 当限流器空闲时，0到Pt耗时为0.5*Tw；

   thresholdPermits = 0.5 * warmupPeriodMicros / stableIntervalMicros;

2. 当限流器空闲时，Pt到Pm耗时为Tw；

   maxPermits = thresholdPermits + 2.0 * warmupPeriodMicros / (stableIntervalMicros + coldIntervalMicros);

3. 当限流器空闲时，初始时，令牌生产速度高，当持有令牌数量达到一定值，生产速度下降；

4. 当从桶接近满的时候开始消耗令牌，消耗速度低（处于warmup阶段），当消耗到一定数量，消耗速度加快；

<font color='red'>（为什么消耗以存在的令牌需要时间？？？）

答：令牌桶内令牌数量一般大于1s内预计达到的QPS，如果不需要消耗时间，当令牌桶存储多余QPS的令牌且外部acquire多余QPS的令牌，流量会瞬间超过限制的QPS（造成流量尖峰现象）。而SmoothBursty消耗令牌不需要时间表明这种限流器是允许尖峰的产生。

</font>







先对上述的变量进行定义
$$
\begin{array}{l}
ts: stableIntervalMicros (稳定区域令牌生产时间) \\
tc: coldIntervalMicros (冷却区域令牌生产时间) \\
T_w: warmupPeriodMicros (进入冷却区且不消耗令牌情况下，令牌生产时间从t_s上升到t_c所需时间)\\
P_t: thresholdPermits (进入冷却区的令牌数量阈值)\\
P_{max}: maxPermits (令牌桶令牌上限数量)
\end{array}
$$

一个令牌生产时间满足一下规则
$$
\begin{equation}
t = \left\{
\begin{array}{l}
ts, & P \leq P_t \\
ts在T_w时间内上升到tc,& P_t \lt P \leq P_{m} 
\end{array}
\right.
\end{equation}
$$
冷却区的令牌生产时间变化斜率slope为
$$
slope = \frac{t_c-t_s}{P_{m}-P_t}
$$
在不消耗令牌情况下，冷却区令牌平均生产时间(线性变换)
$$
\overline{t_{cold}} = \frac{tc+ts}{2}
$$
所以
$$
P_{m} = P_t + T_w * \overline{t_{cold}} = P_t + \frac{T_w}{\frac{tc+ts}{2}}
$$
在不消耗令牌情况下，进入冷却区内生产若干个令牌，需要时间为
$$
\Delta{T} = ts + \frac{\Delta{P} * slope}{2}
$$


Guava的限流器在每次获取令牌时，先同步一次计时器时间

```java
// 调用入口
public double acquire(int permits) {
    long microsToWait = reserve(permits);
    stopwatch.sleepMicrosUninterruptibly(microsToWait);
    return 1.0 * microsToWait / SECONDS.toMicros(1L);
  }

final long reserve(int permits) {
    checkPermits(permits);
    // 并发控制
    synchronized (mutex()) {
      return reserveAndGetWaitLength(permits, stopwatch.readMicros());
    }
  }

final long reserveAndGetWaitLength(int permits, long nowMicros) {
    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);
    return max(momentAvailable - nowMicros, 0);
  }

final long reserveEarliestAvailable(int requiredPermits, long nowMicros) {
    resync(nowMicros);
    long returnValue = nextFreeTicketMicros;
    double storedPermitsToSpend = min(requiredPermits, this.storedPermits);
    // 本次acquire还需要新产生的令牌数
    double freshPermits = requiredPermits - storedPermitsToSpend;
    long waitMicros =
        storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)
      				// 全速生产新令牌
            + (long) (freshPermits * stableIntervalMicros);

    this.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);
    this.storedPermits -= storedPermitsToSpend;
    return returnValue;
  }

void resync(long nowMicros) {
    // if nextFreeTicket is in the past, resync to now
    if (nowMicros > nextFreeTicketMicros) {
      // 两次连续acquire之间产生了多少个令牌
      double newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();
      // 当前桶内拥有令牌数量（多的丢弃）
      storedPermits = min(maxPermits, storedPermits + newPermits);
      nextFreeTicketMicros = nowMicros;
    }
  }

// 消耗桶内令牌需要的时间
long storedPermitsToWaitTime(double storedPermits, double permitsToTake) {
      double availablePermitsAboveThreshold = storedPermits - thresholdPermits;
      long micros = 0;
      // measuring the integral on the right part of the function (the climbing line)
  		// 先从冷却区产生
      if (availablePermitsAboveThreshold > 0.0) {
        double permitsAboveThresholdToTake = min(availablePermitsAboveThreshold, permitsToTake);
        // TODO(cpovirk): Figure out a good name for this variable.
        double length =
            permitsToTime(availablePermitsAboveThreshold)
                + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);
        micros = (long) (permitsAboveThresholdToTake * length / 2.0);
        permitsToTake -= permitsAboveThresholdToTake;
      }
      // measuring the integral on the left part of the function (the horizontal line)
      micros += (long) (stableIntervalMicros * permitsToTake);
      return micros;
    }
```

resync方法中的newPermits则是上一次同步时间到当前同步时间，这个期间内可以产生多少个令牌。

<font color='red'>这里不太理解的是令牌生产耗时计算方法coolDownIntervalMicros</font>

```java
double coolDownIntervalMicros() {
      return warmupPeriodMicros / maxPermits; // 为什么用Tw和Pmax求耗时
    }
```

