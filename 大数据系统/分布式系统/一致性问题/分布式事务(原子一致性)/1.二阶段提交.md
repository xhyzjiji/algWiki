分布式事务能让多个节点上不同的操作，在外部观测上是原子的，一起提交或者一起中止。而实现这一类一致性算法称为原子性提交协议（ACP：atomic commitment protocal）。

> ACP在实现上需要遵循以下原则：
> 
> 1. 所有已经决策的进程，都必须是相同的决定
> 
> 2. 进程一旦决策不能再改变
> 
> 3. 只有所有进程都投Yes赞成票，才能达成commit结果
> 
> 4. 如果没有故障，并且所有进程都投Yes赞成票，事务最终可以达成commit结果
> 
> 5. 假设执行中只包含算法可以容忍的故障，当所有现有故障得到修复，并在足够长的时间内不再有故障发生，那么所有进程都最终能达到一个决定。

# 1 模型定义

在讨论前，先定义界定下讨论问题的范围。首先，我们假设节点只有两种工作状态：（1）正常工作（2）无法工作，也就是fail-stop，而不会执行错误动作，从而对外发送一些错误信息（即非拜占庭）。

（1）计算模型

分布式事务由数个执行任务，分别运行在一组进程上，进程可以运行于相同或不同的节点，节点间通过网络交互数据，执行结果最终存储到各个进程所在节点的本次磁盘空间中。

（2）开销模型

算法开销主要关注一下几个点：

- 一次算法执行的节点间交互消息数量（Round Trip）

- 磁盘同步IO次数和延迟

（3）故障模型

根据FLP定理（**没有任何算法可以在存在任何故障的异步系统中确保达到共识）**，我们下面讨论的网络交互都是基于异步模型（相对于同步模型，同步模型下可以对消息传递时间和应答时间设置一个期望上限，通过超时来检测故障），很多时候都无法预估对端的响应时间，所以在生产中，需要设计一个健壮且有实现意义的一致性算法，而非一个可以完美被证明的算法。

*** TODO：FLP证明安排一下 ***

计算模型决定着故障模型，关注的故障类型主要有：

- 消息可能丢失、重复，但不存在损坏的消息

- 一个执行失败的节点会停止动作（故障-停止模型：fail-stop），而不会对外发送错误消息（非随机故障模型：Byzantine）

- 节点宕机，为了使节点宕机恢复后不会丢失本地状态，实现的时候还需要考虑将自身的数据、上下文信息持久化到本地磁盘

# 2 二阶段提交

## 2.1 协议简介

最简单的ACP是二阶段提交（2PC：2 Phase Commit）。

- 角色
  
  协调者：2PC会假定一个协调者，负责保存状态、收集参与者投票结果，并根据投票结果决定第二阶段的协商动作（commit 还是 abort）。协调者可以是接收事务请求的节点，也可以通过选主算法得出。协议本身对协调者角色没有任何限制条件。
  
  参与者：其余的是参与者，参与者可以根据本地资源情况，投票接受（Yes）或者拒绝（No）应答给协调者。
  
  一个事务里，协调者和参与者是互相感知，但参与这之间没有强制要求相互感知。

- 过程
  
  顾名思义，协议分为两个阶段：
  
  1. prepare 阶段
     
     协调者广播提议到<font color='red'>“所有”</font>参与者，阻塞等待并收集本提议实例（propose instance）“所有”参与者的投票结果，如果收到拒绝提议的应答，协调者广播abort命令给所有参与者，对事务进行回滚。
  
  2. commit / abort 阶段
     
     但凡有一个参与者投票拒绝提案，协调者会像所有参与者发送abort命令，只有参与者都头赞成票，协调者才会广播commit命令给所有参与者，参与者各自提交自身的事务。
  
  Normal Case Operation（一个没有故障场景下的完整交互过程）
  
  ![2pc.png](/Users/panyongfeng/Documents/basic_framework/wiki/大数据系统/分布式系统/一致性问题/分布式事务(原子一致性)/pics/2pc.png)

> 分布式事务中隐含了本地事务，分布式事务的一致性建立在本地事务的一致性上，而往往在工程实践和实际需求中，事务完全串行化在性能上无法被接受，许多数据库会使用较弱的隔离级别，防止大部分事务间的并发问题。不过，这么做引入了一些复杂度和隐患，比如：脏读、幻读、更新丢失、读倾斜、写倾斜等问题，最终表现上就是数据不一致。
> 
> （1）读倾斜：也叫读偏序
> 
> ![read-skew.png](/Users/panyongfeng/Documents/basic_framework/wiki/大数据系统/分布式系统/一致性问题/分布式事务(原子一致性)/pics/read-skew.png)
> 
> 假设X、Y满足一定规则（比如：X+Y=100），事务1在读出X和Y时，可能被事务2破坏了原有的约束条件。可以通过读快照解决这个问题。
> 
> （2）写倾斜：
> 
> ![write-skew.png](/Users/panyongfeng/Documents/basic_framework/wiki/大数据系统/分布式系统/一致性问题/分布式事务(原子一致性)/pics/write-skew.png)
> 
> 假设事务1、2都根据读出的X值，然后根据查询结果更新与X相关的值。可以通过实体化冲突后，然后显式加锁（二阶段锁）来解决这个问题。

## 2.2 故障与恢复

1. 通信故障
   
   从故障模型来看，通信故障可以是：网络超时、消息损坏、节点高负载导致处理超时（消息可能被执行或还没有执行）、节点长时间宕机没有响应、网络分区等。
   
   不管是什么故障，在协调者眼中，都可以归纳为参与者响应超时，2PC也不对故障类型做任何假设。
   
   我们约定：
   
   1. 协调者等待应答超时
   
   2. 参与者等待协调者命令超时
   
   <font color='red'>节点默认单方面对事务进行abort。</font>
   
   > :question: 如果单方面对事务commit，会有什么后果？
   
   我们分析下2PC过程中，不同阶段超时带来什么后果：
   
   ![](/Users/panyongfeng/Documents/basic_framework/wiki/大数据系统/分布式系统/一致性问题/分布式事务(原子一致性)/pics/2pc_timeout.png)

  （1）协调者Prepare后等待参与者应答超时：协调者可以单方面abort事务，并广播Abort命令

  （2）参与者等待协调者Commit和Abort命令超时：

  这个时候，参与者已经投票，所以无法反悔；而协调者可能处于宕机状态，或者参与者与协调者处于网络分区，<font color='red'>事务处于不确定状态</font>；（见小节3：中止协议）

  （3）协调者等待参与者应答事务处理结果超时：

  这个时候，参与者可能收到命令，执行完成，但应答超时；或者参与者根本没有收到命令，也没有执行最后的commit动作，<font color='red'>事务处于不确定状态</font>；（见小节3：中止协议）



2. 节点宕机恢复
   
   （1）宕机
   
   为了可以在节点（可能是协调者，也可能是参与者）宕机时不丢失事务状态，恢复后继续未完成的事务，需要额外引入WAL，记录事务的上下文信息。以事务提交为例：
   
   ![2pc_recovery.png](/Users/panyongfeng/Documents/basic_framework/wiki/大数据系统/分布式系统/一致性问题/分布式事务(原子一致性)/pics/2pc_recovery.png)
   
   > Prepare日志：表示事务的开端，只有事务的协调者存在这个日志，这个日志可以记录事务信息和参与者信息，Prepare日志可以异步记录；
   > 
   > Yes/No日志：参与这在回复协调者投票意愿前，需要同步记录投票结果，再发送应答消息，Yes/No日志也需要记录事务信息和协调者信息，以便协调者咨询事务状态；
   > 
   > Commit/Abort日志：协调者在收到参与者的投票结果后，可以得出之后的动作时，需要同步记录事务是commit还是abort，然后再广播命令到参与者；
   > 
   > Finish日志：协调者在收到所有参与者的处理结果后，就可以写入事务结束标志事件，Finish日志可以异步记录；

   （2）恢复过程

   通过识别Prepare日志，可以得知节点对于该事务的角色，如果存在则是协调者，否则为参与者。

1. 协调者
   
   1. 如果存在Commit/Abort日志，则表明已经做出事务决定，向参与者确认事务提交结果即可（没有提交的节点继续执行Commit/Abort即可），然后补充Finish日志；
   
   2. 如果不存在Commit/Abort日志，则需要向参与者确认投票结果，然后进入Commit/Abort阶段；

2. 参与者
   
   1. 如果存在Commit/Abort日志，则参与者已经完成事务；
   
   2. 如果不存在Yes日志（可能要投Yes或者直接Abort），这个时候参与者可以单方面选择Abort，不会影响事务结果（协调者此时可能因参与者应答超时回滚事务）；
   
   3. 如果存在Yes日志，但是不存在Commit/Abort日志，事务处于未决状态，进入中止协议；
   
   *** TODO: 补一个状态转移图方便理解 ***
   
   （3）日志GC
   
   由于引入了本地日志，需要考虑日志GC的时机和约束。日志GC需要遵守下面的原则：
   
   - 至少需要本地事务commit或abort后，才可以清理该事务相关日志；
   
   - 保证至少有一个节点，得知事务设计的所有节点都执行了commit或abort后，才能删除该事务相关日志；
     
     根据上述的原则，协调者可以收集完成的事务结果，定时批量的广播到各个参与者，便于参与者了解事务是否结束，从而GC掉本地日志来回收空间。



3. 中止协议（termination protocol）
   
   当出现通信故障、协调者节点故障且无法恢复的情况时，未完成的事务会处于<mark>不确定状态（未决）</mark>，事务资源需要得到释放，所以又引入了中止协议。
   
   中止协议原理很简单，<font color='red'>参与者节点感知事务超时</font>后，向其他节点主动询问事务状态，当有节点明确发送事务状态后，按状态执行未完成的流程。
   
   ![2pc_termination_protocol.png](/Users/panyongfeng/Documents/basic_framework/wiki/大数据系统/分布式系统/一致性问题/分布式事务(原子一致性)/pics/2pc_termination_protocol.png)
   
   例子：Commit命令丢失的情况
   
   上面提及2PC协议，参与者不需要相互感知，与中止协议的需求是相悖的。所以，如果需要实现中止协议，需要在prepare请求中带上这个事务所有的参与者信息，同时参与者持久化事务上下文的时候也同样要记录这些信息。
   
   注意，中止协议也并非都能解决极端的故障场景：
   
   如果所有参与者都投Yes，但协调者在commit阶段发送消息前宕机，参与者无法单方面决定事务最终执行状态，广播请求事务状态，参与者都是返回事务未决的状态。
   
   ![2pc_tp2.png](/Users/panyongfeng/Documents/basic_framework/wiki/大数据系统/分布式系统/一致性问题/分布式事务(原子一致性)/pics/2pc_tp2.png)
   
   这里可以修正一下：广播获取事务状态，参与者可以返回自身投票的结果，如果参与者收集到其他所有参与者的投票结果，自身也能进行commit。



## 2.3 总结和工程优化

（1）复杂度（根据开销模型）

1. 消息量
   
   - 正常流程
     
     2PC需要2次RT来达成节点间原子事务提交
   
   - 中止协议
     
     因为中止协议需要未确定事务状态的参与者广播请求事务结果，所以最差的情况下会增加消息量 ，其中n为该事务关联参与者的进程总数

2. 持久化延迟
   
   从上面的分析可以得出，整个协议过程需要2次本地同步IO

（2）工程优化

- 减少本地同步IO次数
  
  协调者Commit日志转为异步记录，这时候恢复事务时，如果不存在Commit日志，重新咨询参与者事务状态来恢复即可；

- 当协调者宕机恢复时，需要先恢复未完成事务后，才能对外服务
  
  恢复后，参与者根据本地redo log对事务变更的记录提前加锁，然后即可恢复服务（因为如果新事务与恢复事务存在冲突会被阻塞）；

- 减少消息量
  
  协调者在明确参与者投票结果后，立即返回客户端，但此时事务可能尚未提交完成，外部可能观察到半事务或者观察不到事务数据，需要根据应用场景优化（客户端可能需要二次确认事务状态）；

*** TODO：2PC算法证明还没看，看懂了再补充 ***

# 3 三阶段提交

3PC比2PC多了一个阶段：Pre-Commit，当执行了Pre-Commit后，即使协调者宕机，参与者在等待Commit命令超时也可以自行提交事务。

![](/Users/panyongfeng/Documents/basic_framework/wiki/大数据系统/分布式系统/一致性问题/分布式事务(原子一致性)/pics/3pc.png)

3PC与2PC还有个不同的地方是，当参与者超时未接收协调者指令，也会默认提交事务，这时候会破坏事务原子性。

比如：协调者与部分参与者出现网络分区

![](/Users/panyongfeng/Documents/basic_framework/wiki/大数据系统/分布式系统/一致性问题/分布式事务(原子一致性)/pics/3pc_network_partition.png)

即使采用默认Abort事务，三阶段事务也没有根本解决协调者宕机带来的阻塞问题，治标不治本。



参考文献：

1. concurrency control and recovery in database systems-Ch7

2. consensus-on-transaction-commit

3. https://zhuanlan.zhihu.com/p/22594180
